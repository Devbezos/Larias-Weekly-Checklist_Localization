name: Publish Stable

on:
  workflow_dispatch:
  schedule:
    # Check hourly for new commits and/or interface bumps.
    - cron: "0 * * * *"
  push:
    branches:
      - main
      - master

concurrency:
  group: locales-publish-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write

jobs:
  publish:
    # Avoid looping when this workflow pushes a version-bump commit.
    # Allow scheduled/manual runs, and allow other automation pushes.
    if: github.event_name != 'push' || github.actor != 'github-actions[bot]' || !contains(github.event.head_commit.message, 'Auto-release locales')

    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Update .toc Interface versions (latest 3)
        shell: bash
        run: |
          set -euo pipefail
          TOC="LariasWeeklyChecklist_Localization.toc"
          python scripts/update_toc_interface.py --toc "$TOC" --count 3

      - name: Commit + Tag + Push (only if repo changed since last release)
        id: commitstep
        shell: bash
        run: |
          set -euo pipefail

          TOC="LariasWeeklyChecklist_Localization.toc"

          # Ensure stable releases never keep an ALPHA display name.
          sed -i "s/^## Title:.*/## Title: Larias's Weekly Checklist: Localization/" "$TOC"

          # Detect whether we have any new commits since the last *stable* release tag.
          # Important: ignore alpha tags (vX.Y.Z.W-alpha) and 4-part tags (vX.Y.Z.W),
          # otherwise stable can get stuck thinking nothing changed since the last alpha.
          #
          # Note: `git describe --match` uses glob patterns (not regex) and cannot anchor
          # to end-of-string, so it can still match alpha tags. Instead, list tags and
          # filter for exact vMAJOR.MINOR.PATCH.
          LAST_TAG=$(git tag --list 'v*' --sort=-version:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -n 1 || true)
          if [ -n "$LAST_TAG" ]; then
            COMMITS_SINCE_TAG=$(git rev-list --count "$LAST_TAG"..HEAD)
          else
            COMMITS_SINCE_TAG=999999
          fi

          echo "Last tag: ${LAST_TAG:-<none>}"
          echo "Commits since tag: ${COMMITS_SINCE_TAG}"

          TOC_CHANGED=false
          if ! git diff --quiet -- "$TOC"; then
            TOC_CHANGED=true
          fi

          echo "TOC changed (working tree): ${TOC_CHANGED}"
          echo "TOC Interface (after update): $(sed -n 's/^## Interface:[[:space:]]*//p' "$TOC" | head -n 1 | tr -d '[:space:]' || true)"

          # Nothing to publish.
          if [ "$COMMITS_SINCE_TAG" -eq 0 ] && [ "$TOC_CHANGED" = "false" ]; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
            echo "released=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Always bump addon version for a publish.
          NEW_VERSION=$(python scripts/bump_toc_version.py --toc "$TOC")
          TAG="v$NEW_VERSION"

          git add "$TOC"
          git commit -m "Auto-release locales ($TAG) [skip ci]" || true
          git push

          git tag -a "$TAG" -m "Release $TAG"
          git push origin "$TAG"

          echo "changed=true" >> "$GITHUB_OUTPUT"
          echo "released=true" >> "$GITHUB_OUTPUT"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

      - name: Check packager config
        id: pkgmeta
        shell: bash
        env:
          CF_API_KEY: ${{ secrets.CF_API_KEY }}
          WAGO_API_TOKEN: ${{ secrets.WAGO_API_TOKEN }}
        run: |
          set -euo pipefail

          if [ ! -f .pkgmeta ]; then
            echo "ready=false" >> "$GITHUB_OUTPUT"
            echo "reason=missing .pkgmeta" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          CF_ID=$(sed -n 's/^curse-project-id:[[:space:]]*//p' .pkgmeta | head -n 1 | tr -d '[:space:]' || true)
          WAGO_ID=$(sed -n 's/^wago-id:[[:space:]]*//p' .pkgmeta | head -n 1 | tr -d '"[:space:]' || true)

          if [ -z "$CF_ID" ]; then CF_ID=0; fi
          if [ "$CF_ID" = "0" ] && [ -z "$WAGO_ID" ]; then
            echo "ready=false" >> "$GITHUB_OUTPUT"
            echo "reason=project IDs not configured (.pkgmeta has curse-project-id: 0 and empty wago-id)" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          CF_ENABLED=false
          WAGO_ENABLED=false
          if [ "$CF_ID" != "0" ] && [ -n "${CF_API_KEY:-}" ]; then
            CF_ENABLED=true
          fi
          if [ -n "$WAGO_ID" ] && [ -n "${WAGO_API_TOKEN:-}" ]; then
            WAGO_ENABLED=true
          fi

          # Diagnostics (do not print secret values)
          echo "CurseForge project id: $CF_ID"
          echo "Wago id: ${WAGO_ID:-<empty>}"
          echo "CurseForge upload enabled: $CF_ENABLED"
          echo "Wago upload enabled: $WAGO_ENABLED"

          if [ "$CF_ENABLED" = "false" ] && [ "$WAGO_ENABLED" = "false" ]; then
            echo "ready=false" >> "$GITHUB_OUTPUT"
            echo "reason=missing upload credentials (CF_API_KEY and/or WAGO_API_TOKEN secrets not set for configured project IDs)" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "ready=true" >> "$GITHUB_OUTPUT"
          echo "reason=ok" >> "$GITHUB_OUTPUT"
          echo "cf_enabled=$CF_ENABLED" >> "$GITHUB_OUTPUT"
          echo "wago_enabled=$WAGO_ENABLED" >> "$GITHUB_OUTPUT"

      - name: Package + Upload (CurseForge & Wago)
        id: packager
        if: steps.commitstep.outputs.released == 'true' && steps.pkgmeta.outputs.ready == 'true'
        uses: BigWigsMods/packager@v2.4.3
        env:
          CF_API_KEY: ${{ secrets.CF_API_KEY }}
          WAGO_API_TOKEN: ${{ secrets.WAGO_API_TOKEN }}

      - name: Inspect packaged ZIP(s)
        if: steps.packager.outcome == 'success'
        shell: bash
        run: |
          set -euo pipefail

          PKG_AS=$(sed -n 's/^package-as:[[:space:]]*//p' .pkgmeta | head -n 1 | tr -d '[:space:]' || true)
          echo "package-as=${PKG_AS:-<missing>}"

          if [ ! -d .release ]; then
            echo "No .release directory found. Packager may have used a different releasedir." >&2
            ls -la
            exit 0
          fi

          echo "== .release contents =="
          find .release -maxdepth 3 -type f -print

          echo "== ZIP preview =="
          while IFS= read -r z; do
            echo "--- $z ---"
            unzip -l "$z" | sed -n '1,60p'
            if [ -n "${PKG_AS:-}" ]; then
              if unzip -l "$z" | grep -qE "[[:space:]]${PKG_AS}/"; then
                echo "‚úÖ Contains top-level folder: ${PKG_AS}/"
              else
                echo "‚ö†Ô∏è Does NOT show expected top-level folder ${PKG_AS}/ in first listing (check full unzip output)."
              fi
            fi
          done < <(find .release -type f -name '*.zip' -print | sort)

      - name: Verify CurseForge upload
        if: steps.commitstep.outputs.released == 'true' && steps.pkgmeta.outputs.ready == 'true'
        shell: bash
        env:
          CF_API_KEY: ${{ secrets.CF_API_KEY }}
          TAG: ${{ steps.commitstep.outputs.tag }}
        run: |
          set -euo pipefail

          CF_ID=$(sed -n 's/^curse-project-id:[[:space:]]*//p' .pkgmeta | head -n 1 | tr -d '[:space:]' || true)
          if [ -z "${CF_ID:-}" ]; then CF_ID=0; fi

          if [ "${CF_ID}" = "0" ]; then
            echo "No curse-project-id in .pkgmeta; skipping verification."
            exit 0
          fi
          if [ -z "${CF_API_KEY:-}" ]; then
            echo "CF_API_KEY not set; skipping verification."
            exit 0
          fi

          VER="${TAG#v}"
          export VER
          echo "Checking CurseForge project ${CF_ID} for version ${VER}"

          for attempt in 1 2 3 4 5 6; do
            echo "Attempt ${attempt}/6..."
            JSON=$(curl -sS -H "x-api-key: ${CF_API_KEY}" "https://api.curseforge.com/v1/mods/${CF_ID}/files?pageSize=10" || true)

            FOUND=$(printf '%s' "$JSON" | python3 -c "import json,os,sys; ver=os.environ.get('VER',''); raw=sys.stdin.read(); obj=json.loads(raw) if raw else {}; files=(obj.get('data') or []) if isinstance(obj,dict) else []; hay=[(f.get('displayName','') or '')+' '+(f.get('fileName','') or '') for f in files if isinstance(f,dict)]; print('true' if (ver and any(ver in s for s in hay)) else 'false')" 2>/dev/null || echo false)

            if [ "${FOUND}" = "true" ]; then
              echo "‚úÖ CurseForge lists a file containing version ${VER} in the last 10 uploads."
              exit 0
            fi

            sleep 20
          done

          echo "‚ùå Could not find version ${VER} in CurseForge file list after retries." >&2
          echo "This suggests packager did not upload to CurseForge (or the project/file naming differs)." >&2
          exit 1

      - name: Summary (why upload did/did not run)
        if: always()
        shell: bash
        env:
          RELEASED: ${{ steps.commitstep.outputs.released }}
          TAG: ${{ steps.commitstep.outputs.tag }}
          PKG_READY: ${{ steps.pkgmeta.outputs.ready }}
          PKG_REASON: ${{ steps.pkgmeta.outputs.reason }}
          PACKAGER_OUTCOME: ${{ steps.packager.outcome }}
        run: |
          echo "released=${RELEASED:-<unset>}"
          echo "tag=${TAG:-<unset>}"
          echo "pkgmeta.ready=${PKG_READY:-<unset>}"
          echo "pkgmeta.reason=${PKG_REASON:-<unset>}"
          echo "packager.outcome=${PACKAGER_OUTCOME:-<unset>}"

      - name: Notify Discord (release posted)
        if: steps.commitstep.outputs.released == 'true' && success()
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          CF_API_KEY: ${{ secrets.CF_API_KEY }}
          TAG: ${{ steps.commitstep.outputs.tag }}
          REPO: ${{ github.repository }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${DISCORD_WEBHOOK_URL:-}" ]; then
            echo "DISCORD_WEBHOOK_URL not set; skipping Discord notification."
            exit 0
          fi

          RELEASE_URL="https://github.com/${REPO}/releases/tag/${TAG}"

          CF_ID=$(sed -n 's/^curse-project-id:[[:space:]]*//p' .pkgmeta | head -n 1 | tr -d '[:space:]' || true)
          if [ -z "${CF_ID:-}" ]; then CF_ID=0; fi
          CURSE_LINE=""
          if [ "${CF_ID}" != "0" ]; then
            CURSE_URL=""
            if [ -n "${CF_API_KEY:-}" ]; then
              SLUG=$(curl -sS -H "x-api-key: ${CF_API_KEY}" "https://api.curseforge.com/v1/mods/${CF_ID}" \
                | python3 -c "import sys,json; data=json.load(sys.stdin).get('data') or {}; print(data.get('slug',''))" 2>/dev/null || true)
              if [ -n "${SLUG:-}" ]; then
                CURSE_URL="https://www.curseforge.com/wow/addons/${SLUG}"
              fi
            fi
            if [ -z "${CURSE_URL:-}" ]; then
              CURSE_URL="https://www.curseforge.com/wow/search?search=${CF_ID}"
            fi
            CURSE_LINE="\nüî• CurseForge: ${CURSE_URL}"
          fi

          payload=$(cat <<EOF
          {
            "content": "üöÄ **Larias's Weekly Checklist: Localization ${TAG}** is live!\n\nüì¶ GitHub: ${RELEASE_URL}${CURSE_LINE}\nüõ† Workflow: ${RUN_URL}"
          }
          EOF
          )

          curl -sS -H "Content-Type: application/json" \
            -d "$payload" \
            "$DISCORD_WEBHOOK_URL" || true

      - name: Note (upload skipped)
        if: steps.commitstep.outputs.released == 'true' && steps.pkgmeta.outputs.ready != 'true'
        shell: bash
        run: |
          echo "Release tag created: ${{ steps.commitstep.outputs.tag }}"
          echo "Upload skipped: ${{ steps.pkgmeta.outputs.reason }}"
