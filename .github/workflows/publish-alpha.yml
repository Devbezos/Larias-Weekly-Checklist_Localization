name: Deploy Alpha

on:
  push:
    branches-ignore:
      # Auto-deploy alphas only from NON long-lived branches.
      # (Long-lived branches like main/release/hotfix should not mint alpha tags.)
      - main
      - develop
      - release/**
      - hotfix/**
    tags-ignore:
      # Prevent the bot's own tag push from re-triggering this workflow.
      # Without this, pushing v*-alpha would re-fire the workflow, causing a
      # second run that races with the original and can loop indefinitely.
      - '**'
  workflow_dispatch:
    inputs:
      target_branch:
        description: "Branch to deploy alpha from (e.g. main, feature/foo)"
        required: false
        default: ""

concurrency:
  group: deploy-alpha-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write

jobs:
  deploy-alpha:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.target_branch || github.ref_name }}

      - name: Get current version
        id: version
        run: |
          # Extract version from .toc file
          CURRENT_VERSION=$(grep "^## Version:" LariasWeeklyChecklist_Localization.toc | sed 's/## Version: //')
          echo "current=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          
          # Get branch name
          BRANCH_NAME="${{ inputs.target_branch || github.ref_name }}"
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Calculate new version
        id: newversion
        env:
          CURRENT: ${{ steps.version.outputs.current }}
        run: |
          set -euo pipefail

          # Ensure tags are available for version calculation.
          git fetch --tags --force

          # Versioning rules for alpha:
          # - Parse MAJOR.MINOR.PATCH from the current stable .toc version.
          # - If alpha tags exist AND their base MAJOR.MINOR.PATCH matches the
          #   .toc version, bump only the BUILD (4th) component.
          # - If the .toc version is AHEAD of the latest alpha tag (e.g. a stable
          #   release was cut and the .toc was bumped), reset BUILD to 1 using
          #   the .toc version as the base.
          # Examples:
          #   toc=1.0.19, latest alpha=v1.0.19.5-alpha  -> 1.0.19.6-alpha
          #   toc=1.0.20, latest alpha=v1.0.19.5-alpha  -> 1.0.20.1-alpha
          #   toc=1.0.20, no alpha tags                 -> 1.0.20.1-alpha

          # Parse MAJOR.MINOR.PATCH from the .toc (strip any pre-existing build component).
          if [[ "${CURRENT:-}" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
            TOC_MAJOR="${BASH_REMATCH[1]}"
            TOC_MINOR="${BASH_REMATCH[2]}"
            TOC_PATCH="${BASH_REMATCH[3]}"
          else
            TOC_MAJOR=0; TOC_MINOR=0; TOC_PATCH=0
          fi

          LATEST_ALPHA_TAG=$(git tag --list 'v*-alpha' --sort=-v:refname | head -n 1 || true)
          if [ -n "${LATEST_ALPHA_TAG:-}" ]; then
            BASE_VERSION="${LATEST_ALPHA_TAG#v}"
            BASE_VERSION="${BASE_VERSION%-alpha}"
            IFS='.' read -r TAG_MAJOR TAG_MINOR TAG_PATCH TAG_BUILD <<< "$BASE_VERSION"
            if [ -z "${TAG_BUILD:-}" ]; then TAG_BUILD=0; fi

            # Compare tag base to .toc; if .toc is strictly ahead, start fresh.
            if [ "$TOC_MAJOR" -gt "$TAG_MAJOR" ] ||
               { [ "$TOC_MAJOR" -eq "$TAG_MAJOR" ] && [ "$TOC_MINOR" -gt "$TAG_MINOR" ]; } ||
               { [ "$TOC_MAJOR" -eq "$TAG_MAJOR" ] && [ "$TOC_MINOR" -eq "$TAG_MINOR" ] && [ "$TOC_PATCH" -gt "$TAG_PATCH" ]; }; then
              MAJOR=$TOC_MAJOR; MINOR=$TOC_MINOR; PATCH=$TOC_PATCH; BUILD=1
            else
              MAJOR=$TAG_MAJOR; MINOR=$TAG_MINOR; PATCH=$TAG_PATCH
              BUILD=$((TAG_BUILD + 1))
            fi
          else
            MAJOR=$TOC_MAJOR; MINOR=$TOC_MINOR; PATCH=$TOC_PATCH; BUILD=1
          fi

          NEW_VERSION="$MAJOR.$MINOR.$PATCH.$BUILD"
          ALPHA_VERSION="$NEW_VERSION-alpha"
          
          echo "new=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "alpha=$ALPHA_VERSION" >> $GITHUB_OUTPUT

      - name: Update version in .toc file
        env:
          ALPHA_VERSION: ${{ steps.newversion.outputs.alpha }}
        run: |
          sed -i "s/^## Version:.*/## Version: $ALPHA_VERSION/" LariasWeeklyChecklist_Localization.toc
          sed -i "s/^## Title:.*/## Title: Larias's Weekly Checklist Localization (ALPHA)/" LariasWeeklyChecklist_Localization.toc

      - name: Commit and tag
        env:
          ALPHA_VERSION: ${{ steps.newversion.outputs.alpha }}
        run: |
          set -euo pipefail

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add LariasWeeklyChecklist_Localization.toc
          git commit -m "Alpha release: $ALPHA_VERSION from ${{ steps.version.outputs.branch }}"
          
          TAG="v$ALPHA_VERSION"
          git tag -a "$TAG" -m "Alpha Release $ALPHA_VERSION"
          git push
          git push origin "$TAG"
          
          echo "tag=$TAG" >> $GITHUB_ENV

      - name: Check packager config
        id: pkgmeta
        shell: bash
        env:
          CF_API_KEY: ${{ secrets.CF_API_KEY }}
          WAGO_API_TOKEN: ${{ secrets.WAGO_API_TOKEN }}
        run: |
          set -euo pipefail

          if [ ! -f .pkgmeta ]; then
            echo "cf_enabled=false" >> "$GITHUB_OUTPUT"
            echo "wago_enabled=false" >> "$GITHUB_OUTPUT"
            echo "cf_id=0" >> "$GITHUB_OUTPUT"
            echo ".pkgmeta missing; uploads will be skipped."
            exit 0
          fi

          CF_ID=$(sed -n 's/^curse-project-id:[[:space:]]*//p' .pkgmeta | head -n 1 | tr -d '[:space:]' || true)
          WAGO_ID=$(sed -n 's/^wago-id:[[:space:]]*//p' .pkgmeta | head -n 1 | tr -d '"[:space:]' || true)

          if [ -z "${CF_ID:-}" ]; then CF_ID=0; fi
          CF_ENABLED=false
          WAGO_ENABLED=false
          if [ "${CF_ID}" != "0" ] && [ -n "${CF_API_KEY:-}" ]; then CF_ENABLED=true; fi
          if [ -n "${WAGO_ID:-}" ] && [ -n "${WAGO_API_TOKEN:-}" ]; then WAGO_ENABLED=true; fi

          echo "CurseForge project id: ${CF_ID}"
          echo "Wago id: ${WAGO_ID:-<empty>}"
          echo "CurseForge upload enabled: ${CF_ENABLED}"
          echo "Wago upload enabled: ${WAGO_ENABLED}"

          echo "cf_enabled=${CF_ENABLED}" >> "$GITHUB_OUTPUT"
          echo "wago_enabled=${WAGO_ENABLED}" >> "$GITHUB_OUTPUT"
          echo "cf_id=${CF_ID}" >> "$GITHUB_OUTPUT"

      - name: Fetch tags (packager)
        shell: bash
        run: |
          set -euo pipefail
          git fetch --tags --force
          git reset --hard v${{ steps.newversion.outputs.alpha }}

      - name: Package + Upload (CurseForge & Wago)
        uses: BigWigsMods/packager@v2.4.3
        env:
          CF_API_KEY: ${{ secrets.CF_API_KEY }}
          WAGO_API_TOKEN: ${{ secrets.WAGO_API_TOKEN }}

      - name: Notify Discord (alpha deployed)
        if: success()
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          CF_API_KEY: ${{ secrets.CF_API_KEY }}
          TAG: v${{ steps.newversion.outputs.alpha }}
          REPO: ${{ github.repository }}
          BRANCH: ${{ steps.version.outputs.branch }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          set -euo pipefail

          RELEASE_URL="https://github.com/${REPO}/releases/tag/${TAG}"
          CF_ID=$(sed -n 's/^curse-project-id:[[:space:]]*//p' .pkgmeta | head -n 1 | tr -d '[:space:]' || true)
          if [ -z "${CF_ID:-}" ]; then CF_ID=0; fi
          CURSE_URL=""
          if [ "${CF_ID}" != "0" ]; then
            if [ -n "${CF_API_KEY:-}" ]; then
              SLUG=$(curl -sS -H "x-api-key: ${CF_API_KEY}" "https://api.curseforge.com/v1/mods/${CF_ID}" \
                | python3 -c "import sys,json; data=json.load(sys.stdin).get('data') or {}; print(data.get('slug',''))" 2>/dev/null || true)
              if [ -n "${SLUG:-}" ]; then
                CURSE_URL="https://www.curseforge.com/wow/addons/${SLUG}"
              fi
            fi
            if [ -z "${CURSE_URL:-}" ]; then
              CURSE_URL="https://www.curseforge.com/wow/search?search=${CF_ID}"
            fi
          fi

          payload=$(cat <<EOF
          {
            "content": "ðŸ§ª **Larias's Weekly Checklist Localization ${TAG}** (ALPHA from \`${BRANCH}\`) is ready!\n\nðŸ“¦ GitHub: ${RELEASE_URL}${CURSE_URL:+\nðŸ”¥ CurseForge: ${CURSE_URL}}\nðŸ›  Workflow: ${RUN_URL}"
          }
          EOF
          )

          curl -sS -H "Content-Type: application/json" \
            -d "$payload" \
            "$DISCORD_WEBHOOK_URL" || true
